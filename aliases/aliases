#!/bin/zsh

# GREP and FIND
alias y='grep -Ri'
alias n='grep -Rvi'

# Recursively check current directory for files containing your argument
alias bigrep="find -type f | xargs grep -in --color=always "

# LS
alias l='ls -lAh --color'
alias ll='ls -l --color'
alias ls='ls --color'
alias al='ls -lhA --color'
alias la='ls -lhA --color'
alias lad="ls -lApF --group-directories-first --color"

# CD
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../../'
alias ....='cd ../../../'
alias .....='cd ../../../../'
alias .4='cd ../../../../'
alias .5='cd ../../../../../'
alias .6='cd ../../../../../../'
alias .7='cd ../../../../../../../'
alias .8='cd ../../../../../../../../'

# DU
alias ducks='du -ckhs * | sort -hr'
alias coin='du -cks * | sort -rn'
alias coincoin='du -ckhs * | sort -hr'
alias mmv='noglob zmv -W'

# NETWORK

# SPY
# returns list of open internet sockets, optionally filter (via grep) for
# host/process/user/etc by adding an argument.
spy() { lsof -i -P +c 0 +M -n | grep -i "$1" }
spyn() { lsof -i -P +c 0 +M | grep -i "$1" }

# MISC
alias c='clear'
# alias a='vim ~/.minimics/aliases/aliases'
alias aloc='vim ~/.aliases.local'

# YOLO AND STUFF FOR YOLO PEOPLE
alias yolo='git commit -am "DEAL WITH IT" && git push origin master'
alias stfu='sudo shutdown -h now'
alias chmog='chmod'

wiki() { if [ "${1}" ]; then dig +short "${1}".wp.dg.cx TXT; fi }

export ROLESKEL="~/ansible/ansible-skel-role"
mkrole() {
    if [ $# -eq 1 ]; then
        ansible-galaxy init --role-skeleton=$ROLESKEL $1
        cd $1
        git init
    else
        echo "Please just add a role name."
    fi
}

#echo "Usage: ando <inventory> '<commands>' <hostname>"
ando() {
    cd ~/cpt-ansible.sys
    ansible -k --ask-sudo-pass -m shell -i inventories/${1} ${3} -m shell -a ${2}
}

reverse() {
    echo -e "IP ADDRESS  \tPING\tREVERSE"; for i in $(nmap -sL -n $1 | grep 'Nmap scan report for' | awk '{ print $5 }'); do echo -e "$i\t$(fping -c1 -t 100 $i > /dev/null 2>&1 && echo -e "\e[32mOK\e[39m" || echo -e "\e[31mKO\e[39m")\t$(dig +short +answer -x $i)"; done
}
